# 算法

- 同一问题的不同解决方法
- 算法往往是针对特定数据结构的
- 测算算法优劣
  - 时间
  - 空间
- 稳定性 如：数组中两个数相等，排序完成后，这些相等数的相对位置可能发生变化

# 常识
## 固定时间

执行时间与数据无关

常数操作: int a + int b, a b都是32位 不管数多大 都是同样的操作，常见常数操作：

```
+ - * / >> >>> << | & ^ 赋值 比较 自增 自减 数组寻址(arr[10000]) ...
数组(arr[])寻址: 内存中取 200万位置 与800万位置 是一样的时间
```

## 非固定时间

执行时间与数据有关，如 LinkedList中 查找200万位置 与800万位置

# 评估算法的优劣

1. 时间复杂度 流程决定，排名：

   - `O(1)` < `O(logN=log 2 n)` < `O(N)` < `O(N*logN)` < `O(N^2)` < `O(N^3)` < .. < `O(N^k)` < `O(2^n)` < `O(3^n)` < .. < `O(k^n)` < `O(N!)`
   
2. 额外空间复杂度 流程决定

3. 常数项时间(不重要) 实现细节决定

   - 例如：^ < + <<< /

## 时间复杂度O(?)

​	常数操作O(1)的数量可以归纳为一个n(需要计算的n个数)的m次方的m阶方程式，例如a*n^m + b*n^(m-1) + ... + c*n + d，则此算法的时间复杂度为O(n^m)，读big O n的m次方。

​	即 将过程拆分 确保拆分后的每一个操作都是**时间固定**的操作(例如常数操作)，并可用f(n）函数表示,其中**最大的指数级**就是时间复杂度

**如: 选择排序,n个数  O(N^2)**
    // 常数操作:交换 比较, 时间复杂度为O(1);
    // n-1次比较, 比较总共的复杂度为(n-1)*O(1)
    第1次循环 0~n-1 比较n-1次 与0位置交换 复杂度=(n-1)*O(1)+O(1)
    第2次循环 1~n-1 比较n-2次 与0位置交换 复杂度=(n-2)*O(1)+O(1)
    第3次循环 2~n-1 比较n-3次 与0位置交换 复杂度=(n-3)*O(1)+O(1)
    ...
    第n-2次循环 n-3~n-1 比较2次 与0位置交换 复杂度=2*O(1)+O(1)
    第n-1次循环 n-2~n-1 比较1次 与0位置交换 复杂度=1*O(1)+O(1)
    ||
    总共进行了f(n)=(n-1)+(n-2)+...+2+1次比较和n-1次交换,得出常数
    化简 f(n)=[(n-1)+1]*(n-1)/2=0.5*n^2+0.5*n
    加上交换n-1 的o(n) = 0.5n^2 + 1.5*n -1
    取最大指数 n^2 得出时间复杂度为O(n^2)

**<u>如果性能随数据状况变化，则取时间复杂度最差状况的值</u>**
**例如 插入排序 a = [1,2,3,4,5,6,7]；b = [7,6,5,4,3,2,1] 取b的时间复杂度**
    b第1次循环 2位置排序插入0~0位置 0~0只有一个数 有序             → [6,7,5,4,3,2,1]
    b第2次循环 3位置排序插入0~1位置 此时0~1位置经过上一次处理已经有序 → [5,6,7,4,3,2,1]
    b第3次循环 4位置排序插入0~2位置 此时0~2位置经过上一次处理已经有序 → [4,5,6,7,3,2,1]
    ...
    直到 → [1,2,3,4,5,6,7]

**二分法时间复杂度:**  log 2 n    --n/2/2/2/2...

## 额外空间复杂度
除了数据的空间 和 算法需要返回的空间O(1), 算法过程中产生的其他空间叫额外空间固定个数的额外空间 = O(1); 其他 >= O(N)

**如**
给定arr[n] 要求算sum
    则int sum += arr[i]
    空间复杂度为O(1)
给定arr[n] 要求统计每个数出现的次数
    假设使用了map保存每个数的个数,按最差的每个数只出现一次算
    空间复杂读为O(N)
给定arr[n] 要求拷贝数据
    arr[n] ans
    空间复杂读为O(1)

# 注意

1. 注意 + * 操作的时候 结果溢出问题





# 学习方法

1. 对着镜子给自己讲
2. 给小白讲明白
3. 手动实现
4. **每一道题都有核心的两三句话，找个小本记下来**
5. 在纸上写20道题

题大怎么聊：比如 f() g() s() 三个黑盒，先聊f g s的调度，再问面试官 你让我实现哪个黑盒

# 笔记

https://shimowendang.com/docs/68cd6h3TwygPwx8W/read

# 学习规划

1. 新手班 -> 体系班1~40
2. 体系班41~47，难度较大，为低频题，但为知识点全面的补充
3. 图快：进阶班 49~78，特别高频
4. 此时可以去面试了
5. 进阶班17~48，经典面试题，跟大厂直播可以不看
6. 大厂刷题班 找新题看

ACM比赛

# 比赛相关

## 预估题目复杂度

预计 10^8 ~10^9 条指令, c语言预计1~2s, java 预计 2~4s
